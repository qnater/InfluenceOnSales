## ADAPTED FROM NETWORKX DOCUMENTATION
## BY SOPHIE CARONI

    __all__ = ["louvain_communities", "louvain_partitions"]
    @py_random_state("seed")

    def louvain_communities(
            G, weight="weight", resolution=1, threshold=0.0000001, seed=None
    ):
        r"""Find the best partition of a graph using the Louvain Community Detection Algorithm.

        Parameters
        ----------
        G : NetworkX graph
        weight : string or None, optional (default="weight")
            The name of an edge attribute that holds the numerical value
            used as a weight. If None then each edge has weight 1.
        resolution : float, optional (default=1)
            If resolution is less than 1, the algorithm favors larger communities.
            Greater than 1 favors smaller communities
        threshold : float, optional (default=0.0000001)
            Modularity gain threshold for each level. If the gain of modularity
            between 2 levels of the algorithm is less than the given threshold
            then the algorithm stops and returns the resulting communities.
        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        Returns
        -------
        list
            A list of sets (partition of `G`). Each set represents one community and contains
            all the nodes that constitute it.

        """

        d = AnalyticsGraph.louvain_partitions(G, weight, resolution, threshold, seed)
        q = deque(d, maxlen=1)
        return q.pop()


    @py_random_state("seed")
    def louvain_partitions(
        G, weight="weight", resolution=1, threshold=0.0000001, seed=None
    ):
        """Yields partitions for each level of the Louvain Community Detection Algorithm

        Parameters
        ----------
        G : NetworkX graph
        weight : string or None, optional (default="weight")
         The name of an edge attribute that holds the numerical value
         used as a weight. If None then each edge has weight 1.
        resolution : float, optional (default=1)
            If resolution is less than 1, the algorithm favors larger communities.
            Greater than 1 favors smaller communities
        threshold : float, optional (default=0.0000001)
         Modularity gain threshold for each level. If the gain of modularity
         between 2 levels of the algorithm is less than the given threshold
         then the algorithm stops and returns the resulting communities.
        seed : integer, random_state, or None (default)
         Indicator of random number generation state.
         See :ref:`Randomness<randomness>`.

        Yields
        ------
        list
            A list of sets (partition of `G`). Each set represents one community and contains
            all the nodes that constitute it.

        """

        partition = [{u} for u in G.nodes()]
        mod = modularity(G, partition, resolution=resolution, weight=weight)
        is_directed = G.is_directed()
        graph = G.__class__()
        graph.add_nodes_from(G)
        graph.add_weighted_edges_from(G.edges(data=weight, default=1))

        m = graph.size(weight="weight")
        partition, inner_partition, improvement = AnalyticsGraph._one_level(
            graph, m, partition, resolution
        )
        improvement = True
        while improvement:
            # gh-5901 protect the sets in the yielded list from further manipulation here
            yield [s.copy() for s in partition]
            new_mod = modularity(
                graph, inner_partition, resolution=resolution, weight="weight"
            )
            if new_mod - mod <= threshold:
                return
            mod = new_mod
            graph = AnalyticsGraph._gen_graph(graph, inner_partition)
            partition, inner_partition, improvement = AnalyticsGraph._one_level(
                graph, m, partition, resolution
            )



    def _one_level(G, m, partition, resolution=1):
        """Calculate one level of the Louvain partitions tree

        Parameters
        ----------
        G : NetworkX Graph/DiGraph
            The graph from which to detect communities
        m : number
            The size of the graph `G`.
        partition : list of sets of nodes
            A valid partition of the graph `G`
        resolution : positive number
            The resolution parameter for computing the modularity of a partition
        is_directed : bool
            True if `G` is a directed graph.
        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        """
        node2com = {u: i for i, u in enumerate(G.nodes())}
        inner_partition = [{u} for u in G.nodes()]
        degrees = dict(G.degree(weight="weight"))
        Stot = list(degrees.values())
        nbrs = {u: {v: data["weight"] for v, data in G[u].items() if v != u} for u in G}
        rand_nodes = list(G.nodes)
        nb_moves = 1
        improvement = False
        while nb_moves > 0:
            nb_moves = 0
            for u in rand_nodes:
                best_mod = 0
                best_com = node2com[u]
                weights2com = AnalyticsGraph._neighbor_weights(nbrs[u], node2com)
                degree = degrees[u]
                Stot[best_com] -= degree
                remove_cost = -weights2com[best_com] / m + resolution * (
                    Stot[best_com] * degree
                ) / (2 * m**2)
                for nbr_com, wt in weights2com.items():
                    gain = (
                        remove_cost
                        + wt / m
                        - resolution * (Stot[nbr_com] * degree) / (2 * m**2)
                    )
                    if gain > best_mod:
                        best_mod = gain
                        best_com = nbr_com
                Stot[best_com] += degree
                if best_com != node2com[u]:
                    com = G.nodes[u].get("nodes", {u})
                    partition[node2com[u]].difference_update(com)
                    inner_partition[node2com[u]].remove(u)
                    partition[best_com].update(com)
                    inner_partition[best_com].add(u)
                    improvement = True
                    nb_moves += 1
                    node2com[u] = best_com
        partition = list(filter(len, partition))
        inner_partition = list(filter(len, inner_partition))
        return partition, inner_partition, improvement


    def _neighbor_weights(nbrs, node2com):
        """Calculate weights between node and its neighbor communities.

        Parameters
        ----------
        nbrs : dictionary
               Dictionary with nodes' neighbours as keys and their edge weight as value.
        node2com : dictionary
               Dictionary with all graph's nodes as keys and their community index as value.

        """
        weights = defaultdict(float)
        for nbr, wt in nbrs.items():
            weights[node2com[nbr]] += wt
        return weights


    def _gen_graph(G, partition):
        """Generate a new graph based on the partitions of a given graph"""
        H = G.__class__()
        node2com = {}
        for i, part in enumerate(partition):
            nodes = set()
            for node in part:
                node2com[node] = i
                nodes.update(G.nodes[node].get("nodes", {node}))
            H.add_node(i, nodes=nodes)

        for node1, node2, wt in G.edges(data=True):
            wt = wt["weight"]
            com1 = node2com[node1]
            com2 = node2com[node2]
            temp = H.get_edge_data(com1, com2, {"weight": 0})["weight"]
            H.add_edge(com1, com2, weight=wt + temp)
        return H


    def _convert_multigraph(G, weight): #, is_directed):
        """Convert a Multigraph to normal Graph"""
        H = nx.Graph()
        H.add_nodes_from(G)
        for u, v, wt in G.edges(data=weight, default=1):
            if H.has_edge(u, v):
                H[u][v]["weight"] += wt
            else:
                H.add_edge(u, v, weight=wt)
        return H
